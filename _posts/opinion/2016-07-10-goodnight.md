---
layout: post
title: 晚安
category: opinion
description: goodnight
---

  
  圈圈叉叉是指下面这个游戏，规则十分简单，就是圈圈或叉叉先连成线(横、纵、斜)就赢，至于圈圈叉叉四不四还有其它含义，我实不知情。

  
  
####再会
* 出月亮的夜晚，走路不要打火把，要是走路打火把，月亮就伤心了。——高行健
* 我们都是孤独的刺猬，只有频率相同的人，才能看见彼此内心深处不为人知的优雅。我相信这世上一定有一个能感受到自己的人，那人未必是恋人，他可能是任何人，在偌大的世界中，我们会因为这份珍贵的懂得而不再孤独。——妙莉叶·芭贝里

####唯心
* 人不是苟死苟活的物类，不是以过程的漫长为自豪，而是以过程的精彩、尊贵和独具爱愿为骄傲的。——史铁生
* 以前以为坚持就是永不动摇，现在才明白，坚持是犹豫着、退缩着、心猿意马着，但还在继续往前走 。
* 我对生活中的一切，都是在诀别时才喜爱，而不是与之相逢时；都是在分离时才喜爱，而不是与之相融时；都是偏爱死，而不是生。
* 无敌是多么让人寂寞。

####宿命  
* 谁终将声震人间，必长久深自缄默；谁终将点燃闪电，必长久如云漂泊。—— 尼采  
* 对每个人而言，真正的职责只有一个：找到自我。然后在心中坚守其一生，全心全意，永不停息。——赫尔曼·黑塞
* 当你坐在一个人面前，听他开口说话，看得到各种复杂、精密的境况和命运，如何最终雕刻出这样的性格、思想、做法、长相，这才是理解。而有了这样的眼睛，你才算真正“看见”那个人，也才会发觉，这世界最美的风景，是一个个活出各自模样和体系的人。——蔡崇达《皮囊》
* 向着茫茫的太虚中吹一口气，西西弗斯轻轻说出了自己的秘密：如果真的有人生的要义，那就是你要无比投入地认真玩耍，做一个永远的少年。
 
####心灵硫酸
 
  上面的一段介绍可能有点啰嗦，但只有这样才能把你的思路翻译给计算机听，让计算机发挥其计算优势帮你分析。上面的整个过程整理一下: 
  
* 随口答应，还不如认真拒绝。承诺有限，精力紧张，大家可以学习另外两种技能：随口拒绝讨厌鬼，认真答应心上人。——张嘉佳
* 雨濛濛，日日龙日龙。洗出远山三四重。分明眉黛浓。野桥西，官路东。小驿夜凉风入松。
* 梦境中的我是一个爱走路的人，喜欢找一条人迹罕至的漂亮马路，悠然地行走。走过斑斑树荫的时候，像是走过了自己心中明明灭灭的悲喜。——严歌苓 《陆犯焉识》
* 4)   对0位置走法进行收益评估，明显收益和w呈正比和v呈反比，可以直接表示为w/v，不过，这样会漏算，就是当w和v已经固定，在其它位置比如1,2..8位置所做的尝试越多，你的收益应该是更大的。所以再把前面的收益值改造下，把所有尝试推演的次数记录为V,得到收益为w/v + UCTK * sqrt(2*log(V)/v);
* 5) 0位置的收益值有了，那就把剩下位置的收益值都算出来，排个序，选出收益值最大的走法下手;
* 6) 继续整个过程，直到世界的尽头。

  整个过程多么滴像一颗树(要是不像就没法继续往下扯了)。这颗树的根是我们的初始状态，每种走法就是一个树的枝桠，树上一个个节就是走到这一步的收益，不断推演，这棵树不断开枝散叶，终于到达胜负叶。每一步你只需要沿着节点最肥硕的枝桠走下去，就能大概率的获取胜利。这就是蒙特卡洛搜索树了。 


####星驰
  那么现实世界中，这种方法会有什么用武之地呢，比如在股票市场上进行投资决策，别说，根据我的观察，这种方法看似简单，如果没有数据和规则，的确是丁点用处都没有。圈圈叉叉的游戏之所以可以用蒙特卡洛搜索树来模拟，是因为:  
  
* 理性人，双方走子都在逻辑范畴下，不会忽然抽风;
* 规则透明，成线即赢;
* 信息对等；我知道你下在哪里了;
* 收益可评估，赢的概率可被量化。

  所以现阶段用这种方法给自己益个智还行，要实际应用则困难重重，更别提智能了。我们的智能不仅在于反应速度，知识容量，更在于能举一反三，见微知著及知识的碰撞所产生的无限创意。现在为止人的思维还是无法被推理演绎，只能根据结果进行模拟。
  
####最后

  比起这个复杂纷乱的真实世界，0和1黑与白的宇宙简洁明快得多，最后还是用代码来无情演示([源地址][1]):
  
	from math import *
	import random	
	
	class OXOState:
		""" 圈圈叉叉游戏状态，每个位置由0到8编号，包括三种状态，空位、被圈圈占据，被叉叉占据:
			012
			345
			678
			where 0 = empty, 1 = player 1 (X), 2 = player 2 (O)
		"""
		def __init__(self):
			self.playerJustMoved = 2 # 将上一步走子的人设置为2，表示开始应该是1先走
			self.board = [0,0,0,0,0,0,0,0,0] # 0 = empty, 1 = player 1, 2 = player 2
			
		def Clone(self):
			st = OXOState()
			st.playerJustMoved = self.playerJustMoved
			st.board = self.board[:]
			return st
	

		
- [MCTS](http://mcts.ai/about/index.html)
- [蒙特卡洛树搜索 MCTS](http://www.jianshu.com/p/d011baff6b64)
- [AlphaGo的算法等技术分析](http://mp.weixin.qq.com/s?__biz=MzI2NjA3NTc4Ng==&mid=402878207&idx=1&sn=a1e85787363d827cd4f922f3ea5579b7&scene=2&srcid=0310JY79IaIsL7h9PV4bdJpB&from=timeline&isappinstalled=0)


[1]:    http://mcts.ai/about/index.html  (MCTS)